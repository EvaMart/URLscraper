import sys
sys.path.append('..') # add parent dir in the directories to look for modules 
import json
import shutil

import requests

from basic_analysis import sentences


"""
useful code at: https://gist.github.com/gbaman/b3137e18c739e0cf98539bf4ec4366ad
"""

query_template = """
{
  repository(owner: "%s", name: "%s") {
    defaultBranchRef {
      target {
        ... on Commit {
          history(first: 1 until: "2019-12-03T14:23:00") {
            nodes {
              tree {
                entries {
                  name
                  object {
                    ... on Tree {
                      entries {
                        name
                        object {
                          ... on Tree {
                            entries {
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
"""

import requests


headers = {
    "Authorization": "token b560b1f41290ce3337becec63c8f3c6bb3cbff0e"
}  # my key generated by GitHub.


def run_query(
    query,
):  # A simple function to use requests.post to make the API call. Note the json= section.
    request = requests.post(
        "https://api.github.com/graphql", json={"query": query}, headers=headers
    )
    if request.status_code == 200:
        return request.json()
    else:
        raise Exception(
            "Query failed to run by returning code of {}. {}".format(
                request.status_code, query
            )
        )


def queryGitHub(owner, repo):
    query = query_template % (owner, repo)
    result = run_query(query)  # Execute the query

    return result


def checkCandidateGitFiles(owner, repo):

    response = queryGitHub(owner, repo)
    entries = response["data"]["repository"]["defaultBranchRef"]["target"]["history"][
        "nodes"
    ][0]["tree"]["entries"]
    files = []
    directories = []
    # we explore three levels of depth in the files tree
    for it in entries:

        if it["object"] != None and "entries" in it["object"].keys():

            path = it["name"]
            directories.append(path)

            for it2 in it["object"]["entries"]:
                files.append(path + "/" + it2["name"])

                if it2["object"] != None and "entries" in it2["object"].keys():

                    path2 = path + "/" + it2["name"]
                    directories.append(path2)

                    for it3 in it2["object"]["entries"]:
                        files.append(path2 + "/" + it3["name"])

        else:
            files.append(it["name"])

    common_names = ["readme", "README", "Manual", "manual", "tutorial"]

    candidates = []  # files that contain a common documentation name

    for name in files:
        if True in [t in name for t in common_names]:
            candidates.append(name)

    return (candidates, directories)


def isNamePresent(tool_name, token):
    """
    input: tool name and token (string)
    """
    if tool_name.lower() in token.lower():
        return True
    else:
        return False
    # lowercase everything


def isNameInRepoName(tool_name, repo_link):
    return isNamePresent(tool_name, repo_link)


def isNameInFile(tool_name, file, file_path):
    sents = []
    for line in file:
        # Split into sentences
        sents += sentences.token_sentSplit(line)
    # Tokenize and clean sentences
    tokens = sentences.getCorpusTokens(sents)
    # Check if tool_name in any token
    n_mentions = 0
    for token in tokens:
        if isNamePresent(tool_name, token):
            n_mentions += 1
    print("Name was found %d times in %s" % (n_mentions, file_path))

    return n_mentions


def isToolNameInRepo(link, tool_name):
    """
    This is the MAIN function in this script
    Runs the whole process
    """
    SCORE = [0]

    if isNameInRepoName(
        tool_name, link
    ):  # if tool name in repo link, we assume its the associated github
        print("Tool name is present in repository URL")
        SCORE[0] = 1
        # return(True)

    # else:
    """
    print("Tool name not present in repository URL.\n")

    #####   1. Look for candidate useful files   ########

    if 'github.com' in link:
      fields = link.split('github.com/')
      fields = fields[1].split("/")
      owner = fields[0]
      repo = fields[1]
    else:
      repo = link.split("/")[-1]
      owner = link.split("/")[-2]
    
    candidates, directories = checkCandidateGitFiles(owner, repo)

    names_w_toolname = []
    for nam in directories:
        if isNamePresent(tool_name, nam): # looking for tool name in repo folder
            names_w_toolname.append(nam)
            #return(True)

    if len(names_w_toolname)>0:
        print("Tool name detected in the name of the following directories:")
        SCORE[1] = len(names_w_toolname)
        [print("\t%s"%(a)) for a in names_w_toolname]
        
    print("\nStarting exploration of text in documentation files...\n")

    #####   2. clone repo   #############################

    from git import Repo
    import glob

    git_url_st ="https://github.com/{0}/{1}.git"
    git_url = git_url_st.format(owner, repo)
    
    repo_dir = "tmpgit" # temporal local directory to clone the repo
    Repo.clone_from(git_url, repo_dir)

    #####  3. read those files   #######################

    N_mentions = 0
    for file_p in candidates:
        file = repo_dir + "/" + file_p
        with open(file, 'r') as f:
            N_mentions += isNameInFile(tool_name, f, file_p)
    
    print("\nTool_name found a total of %d times inside files."%(N_mentions))
    SCORE[2] = N_mentions
    
    shutil.rmtree('tmpgit') # removing the directory
    """
    return SCORE


if __name__ == "__main__":

    link = "https://github.com/samocooper/nuclitrack/blob/master/docs/index.rst"

    # link = 'https://github.com/inab/FAIRsoft'
    tool_name = "nuclitrack"  # this should be passed as argument

    isToolNameInRepo(link, tool_name)


## 4. If name in readme -> High score
## 5. If mame not in readme -> Low score
